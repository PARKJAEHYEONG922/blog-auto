interface YouTubeAPIConfig {
  apiKey: string;
}

export interface YouTubeVideoItem {
  id: {
    videoId: string;
  };
  snippet: {
    title: string;
    description: string;
    channelTitle: string;
    channelId: string;
    publishedAt: string;
    thumbnails: {
      default: {
        url: string;
      };
    };
    tags?: string[];
    categoryId?: string;
  };
}

interface YouTubeVideoDetails {
  id: string;
  statistics: {
    viewCount: string;
    likeCount?: string;
    commentCount?: string;
  };
  contentDetails: {
    duration: string;
    definition: string;
    caption: string;
  };
  snippet: {
    channelId: string;
    publishedAt: string;
    title: string;
  };
}

interface YouTubeChannelDetails {
  id: string;
  statistics: {
    subscriberCount: string;
  };
}

export interface PrioritizedVideo {
  videoId: string;
  title: string;
  channelTitle: string;
  publishedAt: string;
  viewCount: number;
  duration: number; // seconds
  subscriberCount?: number;
  priority: number;
  url: string;
}

export interface SubtitleTrack {
  language: string;
  text: string;
  isAutoGenerated: boolean;
}

interface YouTubeSearchResponse {
  items: YouTubeVideoItem[];
  pageInfo: {
    totalResults: number;
    resultsPerPage: number;
  };
}

export class YouTubeAPI {
  private config: YouTubeAPIConfig | null = null;

  async loadConfig(): Promise<void> {
    try {
      // YouTube API ì„¤ì •ì„ ë¡œì»¬ìŠ¤í† ë¦¬ì§€ë‚˜ Electron ì„¤ì •ì—ì„œ ë¡œë“œ
      if ((window as any).electronAPI && typeof (window as any).electronAPI.loadYouTubeApiSettings === 'function') {
        const result = await (window as any).electronAPI.loadYouTubeApiSettings();
        if (result && result.success && result.data) {
          this.config = {
            apiKey: result.data.apiKey
          };
          console.log('âœ… YouTube API ì„¤ì • ë¡œë“œ ì„±ê³µ');
        } else {
          console.warn('âš ï¸ YouTube API ì„¤ì •ì´ ì—†ìŠµë‹ˆë‹¤');
        }
      } else {
        console.warn('âš ï¸ Electron APIê°€ ì—†ìŠµë‹ˆë‹¤ (ë¸Œë¼ìš°ì € í™˜ê²½)');
      }
    } catch (error) {
      console.error('âŒ YouTube API ì„¤ì • ë¡œë“œ ì‹¤íŒ¨:', error);
      throw new Error(`YouTube API ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: ${error.message}`);
    }
  }

  async searchVideos(keyword: string, maxResults: number = 10): Promise<YouTubeVideoItem[]> {
    if (!this.config) {
      throw new Error('YouTube API ì„¤ì •ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. loadConfig()ë¥¼ ë¨¼ì € í˜¸ì¶œí•˜ì„¸ìš”.');
    }

    try {
      const encodedKeyword = encodeURIComponent(keyword);
      const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodedKeyword}&key=${this.config.apiKey}&type=video&maxResults=${maxResults}&order=relevance`;

      console.log(`ğŸ“º YouTube API ê²€ìƒ‰: ${keyword} (ìµœëŒ€ ${maxResults}ê°œ)`);

      const response = await fetch(url);
      
      if (!response.ok) {
        if (response.status === 403) {
          throw new Error('YouTube API í• ë‹¹ëŸ‰ ì´ˆê³¼ ë˜ëŠ” API í‚¤ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
        } else if (response.status === 400) {
          throw new Error('YouTube API ìš”ì²­ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤');
        } else {
          throw new Error(`YouTube API í˜¸ì¶œ ì‹¤íŒ¨: ${response.status} ${response.statusText}`);
        }
      }

      const data: YouTubeSearchResponse = await response.json();
      
      console.log(`âœ… YouTube ê²€ìƒ‰ ì™„ë£Œ: ${data.items.length}ê°œ ë™ì˜ìƒ`);
      
      return data.items;

    } catch (error) {
      console.error('âŒ YouTube ê²€ìƒ‰ ì‹¤íŒ¨:', error);
      throw error;
    }
  }

  async getVideoDetails(videoId: string): Promise<any> {
    if (!this.config) {
      throw new Error('YouTube API ì„¤ì •ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
    }

    try {
      const url = `https://www.googleapis.com/youtube/v3/videos?part=statistics,contentDetails&id=${videoId}&key=${this.config.apiKey}`;
      
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`YouTube API í˜¸ì¶œ ì‹¤íŒ¨: ${response.status}`);
      }

      const data = await response.json();
      return data.items[0];

    } catch (error) {
      console.error('âŒ YouTube ë™ì˜ìƒ ìƒì„¸ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:', error);
      throw error;
    }
  }

  // ISO 8601 durationì„ ì‚¬ëŒì´ ì½ê¸° ì‰¬ìš´ í˜•íƒœë¡œ ë³€í™˜
  static parseDuration(duration: string): string {
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return '0:00';

    const hours = parseInt(match[1] || '0');
    const minutes = parseInt(match[2] || '0');
    const seconds = parseInt(match[3] || '0');

    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    } else {
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
  }

  // ì¡°íšŒìˆ˜ë¥¼ í•œêµ­ì–´ í˜•íƒœë¡œ ë³€í™˜
  static formatViewCount(viewCount: string): string {
    const count = parseInt(viewCount);
    if (count >= 10000) {
      return `${Math.floor(count / 10000)}ë§ŒíšŒ`;
    } else if (count >= 1000) {
      return `${(count / 1000).toFixed(1)}ì²œíšŒ`;
    } else {
      return `${count}íšŒ`;
    }
  }

  // ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ë™ì˜ìƒ ê²€ìƒ‰ ë° ì„ ë³„
  async searchPrioritizedVideos(keyword: string, maxResults: number = 10): Promise<PrioritizedVideo[]> {
    if (!this.config) {
      throw new Error('YouTube API ì„¤ì •ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. loadConfig()ë¥¼ ë¨¼ì € í˜¸ì¶œí•˜ì„¸ìš”.');
    }

    try {
      console.log(`ğŸ¯ ìš°ì„ ìˆœìœ„ ê¸°ë°˜ YouTube ê²€ìƒ‰: ${keyword}`);

      // 1. ê¸°ë³¸ ê²€ìƒ‰ (ë” ë§ì€ ê²°ê³¼ë¥¼ ê°€ì ¸ì™€ì„œ í•„í„°ë§)
      const searchResults = await this.searchVideosWithFilters(keyword, Math.min(maxResults * 3, 50));
      
      if (searchResults.length === 0) {
        console.warn('ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤');
        return [];
      }

      // 2. ë™ì˜ìƒ ìƒì„¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ë°°ì¹˜ ì²˜ë¦¬)
      const videoIds = searchResults.map(video => video.id.videoId);
      const videoDetails = await this.getMultipleVideoDetails(videoIds);
      
      // 3. ì±„ë„ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ë°°ì¹˜ ì²˜ë¦¬)
      const channelIds = [...new Set(searchResults.map(video => video.snippet.channelId))];
      const channelDetails = await this.getMultipleChannelDetails(channelIds);

      // 4. ìš°ì„ ìˆœìœ„ ê³„ì‚° ë° ì •ë ¬
      const prioritizedVideos: PrioritizedVideo[] = [];

      for (const video of searchResults) {
        const details = videoDetails.find(d => d.id === video.id.videoId);
        const channel = channelDetails.find(c => c.id === video.snippet.channelId);
        
        if (!details) continue;

        const prioritizedVideo: PrioritizedVideo = {
          videoId: video.id.videoId,
          title: video.snippet.title,
          channelTitle: video.snippet.channelTitle,
          publishedAt: video.snippet.publishedAt,
          viewCount: parseInt(details.statistics.viewCount || '0'),
          duration: this.parseDurationToSeconds(details.contentDetails.duration),
          subscriberCount: channel ? parseInt(channel.statistics.subscriberCount || '0') : 0,
          priority: 0,
          url: `https://www.youtube.com/watch?v=${video.id.videoId}`
        };

        // ìš°ì„ ìˆœìœ„ ì ìˆ˜ ê³„ì‚°
        prioritizedVideo.priority = this.calculatePriority(prioritizedVideo);
        
        // ê¸°ë³¸ í•„í„°ë§ ì¡°ê±´
        if (this.passesBasicFilters(prioritizedVideo)) {
          prioritizedVideos.push(prioritizedVideo);
        }
      }

      // 5. ìš°ì„ ìˆœìœ„ ìˆœìœ¼ë¡œ ì •ë ¬ í›„ ìƒìœ„ Nê°œ ë°˜í™˜
      const sortedVideos = prioritizedVideos
        .sort((a, b) => b.priority - a.priority)
        .slice(0, maxResults);

      console.log(`âœ… ìš°ì„ ìˆœìœ„ ë¶„ì„ ì™„ë£Œ: ${sortedVideos.length}ê°œ ë™ì˜ìƒ ì„ ë³„`);
      return sortedVideos;

    } catch (error) {
      console.error('âŒ ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ê²€ìƒ‰ ì‹¤íŒ¨:', error);
      throw error;
    }
  }

  // í•„í„°ê°€ ì ìš©ëœ ê²€ìƒ‰
  private async searchVideosWithFilters(keyword: string, maxResults: number): Promise<YouTubeVideoItem[]> {
    const encodedKeyword = encodeURIComponent(keyword);
    
    // ìµœê·¼ 1ë…„ ì´ë‚´ì˜ ì˜ìƒë§Œ ê²€ìƒ‰
    const oneYearAgo = new Date();
    oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
    const publishedAfter = oneYearAgo.toISOString();

    const url = `https://www.googleapis.com/youtube/v3/search?` +
      `part=snippet&q=${encodedKeyword}&key=${this.config.apiKey}&type=video&maxResults=${maxResults}` +
      `&order=relevance&publishedAfter=${publishedAfter}&videoDuration=medium&videoCaption=any`;

    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`YouTube API ê²€ìƒ‰ ì‹¤íŒ¨: ${response.status}`);
    }

    const data: YouTubeSearchResponse = await response.json();
    return data.items;
  }

  // ì—¬ëŸ¬ ë™ì˜ìƒì˜ ìƒì„¸ ì •ë³´ë¥¼ ë°°ì¹˜ë¡œ ê°€ì ¸ì˜¤ê¸°
  private async getMultipleVideoDetails(videoIds: string[]): Promise<YouTubeVideoDetails[]> {
    if (videoIds.length === 0) return [];

    const batchSize = 50; // YouTube API ì œí•œ
    const results: YouTubeVideoDetails[] = [];

    for (let i = 0; i < videoIds.length; i += batchSize) {
      const batch = videoIds.slice(i, i + batchSize);
      const url = `https://www.googleapis.com/youtube/v3/videos?` +
        `part=statistics,contentDetails,snippet&id=${batch.join(',')}&key=${this.config.apiKey}`;

      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        results.push(...data.items);
      }
    }

    return results;
  }

  // ì—¬ëŸ¬ ì±„ë„ì˜ ìƒì„¸ ì •ë³´ë¥¼ ë°°ì¹˜ë¡œ ê°€ì ¸ì˜¤ê¸°
  private async getMultipleChannelDetails(channelIds: string[]): Promise<YouTubeChannelDetails[]> {
    if (channelIds.length === 0) return [];

    const batchSize = 50;
    const results: YouTubeChannelDetails[] = [];

    for (let i = 0; i < channelIds.length; i += batchSize) {
      const batch = channelIds.slice(i, i + batchSize);
      const url = `https://www.googleapis.com/youtube/v3/channels?` +
        `part=statistics&id=${batch.join(',')}&key=${this.config.apiKey}`;

      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        results.push(...data.items);
      }
    }

    return results;
  }

  // ìš°ì„ ìˆœìœ„ ì ìˆ˜ ê³„ì‚°
  private calculatePriority(video: PrioritizedVideo): number {
    let score = 0;

    // 1. ì¡°íšŒìˆ˜ ì ìˆ˜ (40%)
    if (video.viewCount > 1000000) score += 40;
    else if (video.viewCount > 100000) score += 30;
    else if (video.viewCount > 10000) score += 20;
    else if (video.viewCount > 1000) score += 10;

    // 2. ì—…ë¡œë“œ ë‚ ì§œ ì ìˆ˜ (25%)
    const daysSince = (Date.now() - new Date(video.publishedAt).getTime()) / (1000 * 60 * 60 * 24);
    if (daysSince < 30) score += 25;      // 1ê°œì›” ì´ë‚´
    else if (daysSince < 90) score += 20; // 3ê°œì›” ì´ë‚´
    else if (daysSince < 180) score += 15; // 6ê°œì›” ì´ë‚´
    else if (daysSince < 365) score += 10; // 1ë…„ ì´ë‚´

    // 3. ì˜ìƒ ê¸¸ì´ ì ìˆ˜ (20%)
    if (video.duration >= 300 && video.duration <= 1200) score += 20; // 5-20ë¶„
    else if (video.duration >= 180 && video.duration <= 1800) score += 15; // 3-30ë¶„
    else if (video.duration >= 120) score += 10; // 2ë¶„ ì´ìƒ

    // 4. ì±„ë„ ì‹ ë¢°ì„± ì ìˆ˜ (15%)
    if (video.subscriberCount && video.subscriberCount > 100000) score += 15;
    else if (video.subscriberCount && video.subscriberCount > 10000) score += 10;
    else if (video.subscriberCount && video.subscriberCount > 1000) score += 5;

    return score;
  }

  // ê¸°ë³¸ í•„í„°ë§ ì¡°ê±´
  private passesBasicFilters(video: PrioritizedVideo): boolean {
    // ìµœì†Œ ì¡°ê±´ë“¤
    if (video.viewCount < 100) return false; // ìµœì†Œ ì¡°íšŒìˆ˜
    if (video.duration < 60) return false;   // ìµœì†Œ 1ë¶„
    if (video.duration > 3600) return false; // ìµœëŒ€ 1ì‹œê°„
    
    // 1ë…„ ì´ë‚´ ì˜ìƒë§Œ
    const oneYearAgo = Date.now() - (365 * 24 * 60 * 60 * 1000);
    if (new Date(video.publishedAt).getTime() < oneYearAgo) return false;

    return true;
  }

  // ISO 8601 durationì„ ì´ˆë¡œ ë³€í™˜
  private parseDurationToSeconds(duration: string): number {
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return 0;

    const hours = parseInt(match[1] || '0');
    const minutes = parseInt(match[2] || '0');
    const seconds = parseInt(match[3] || '0');

    return hours * 3600 + minutes * 60 + seconds;
  }

  // ìë§‰ ì¶”ì¶œ (ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì—†ì´ êµ¬í˜„)
  async extractSubtitles(videoId: string): Promise<SubtitleTrack[]> {
    try {
      console.log(`ğŸ“ ìë§‰ ì¶”ì¶œ ì‹œì‘: ${videoId}`);

      // YouTube ìë§‰ì€ ì§ì ‘ APIë¡œ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ì–´ì„œ 
      // ëŒ€ì²´ ë°©ë²•ì„ ì‚¬ìš© (youtube-transcript ê°™ì€ npm íŒ¨í‚¤ì§€ê°€ í•„ìš”)
      
      // ì¼ë‹¨ APIë¡œ ìë§‰ íŠ¸ë™ ëª©ë¡ì€ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŒ
      const captionTracks = await this.getCaptionTracks(videoId);
      
      if (captionTracks.length === 0) {
        console.warn(`ìë§‰ì´ ì—†ëŠ” ë™ì˜ìƒ: ${videoId}`);
        return [];
      }

      // ì‹¤ì œ ìë§‰ í…ìŠ¤íŠ¸ëŠ” ë³„ë„ ì„œë¹„ìŠ¤ë‚˜ ë¼ì´ë¸ŒëŸ¬ë¦¬ í•„ìš”
      // ì—¬ê¸°ì„œëŠ” êµ¬ì¡°ë§Œ ì¤€ë¹„
      const subtitles: SubtitleTrack[] = [];
      
      for (const track of captionTracks) {
        try {
          const subtitleText = await this.fetchSubtitleText(track.id);
          subtitles.push({
            language: track.language,
            text: subtitleText,
            isAutoGenerated: track.kind === 'asr'
          });
        } catch (error) {
          console.warn(`ìë§‰ ì¶”ì¶œ ì‹¤íŒ¨ (${track.language}):`, error);
        }
      }

      console.log(`âœ… ìë§‰ ì¶”ì¶œ ì™„ë£Œ: ${subtitles.length}ê°œ ì–¸ì–´`);
      return subtitles;

    } catch (error) {
      console.error(`âŒ ìë§‰ ì¶”ì¶œ ì‹¤íŒ¨: ${videoId}`, error);
      return [];
    }
  }

  // ìë§‰ íŠ¸ë™ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
  private async getCaptionTracks(videoId: string): Promise<any[]> {
    const url = `https://www.googleapis.com/youtube/v3/captions?part=snippet&videoId=${videoId}&key=${this.config.apiKey}`;
    
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`ìë§‰ íŠ¸ë™ ì¡°íšŒ ì‹¤íŒ¨: ${response.status}`);
    }

    const data = await response.json();
    return data.items || [];
  }

  // ì‹¤ì œ ìë§‰ í…ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸° (youtube-transcript ì‚¬ìš©)
  private async fetchSubtitleText(videoId: string, language?: string): Promise<string> {
    try {
      // Node.js í™˜ê²½ì—ì„œë§Œ ë™ì‘
      if (typeof window !== 'undefined') {
        console.warn('ìë§‰ ì¶”ì¶œì€ Node.js í™˜ê²½ì—ì„œë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤');
        return '';
      }

      // youtube-transcript ë™ì  import
      const { YoutubeTranscript } = await import('youtube-transcript');
      
      const transcript = await YoutubeTranscript.fetchTranscript(videoId, {
        lang: language || 'ko'
      });

      // ìë§‰ í…ìŠ¤íŠ¸ ì¡°í•©
      const fullText = transcript
        .map(item => item.text)
        .join(' ')
        .replace(/\s+/g, ' ')
        .trim();

      return fullText;

    } catch (error) {
      console.warn(`ìë§‰ ì¶”ì¶œ ì‹¤íŒ¨ (${videoId}):`, error.message);
      
      // í•œêµ­ì–´ ìë§‰ì´ ì—†ìœ¼ë©´ ì˜ì–´ ì‹œë„
      if (language !== 'en') {
        try {
          return await this.fetchSubtitleText(videoId, 'en');
        } catch (enError) {
          console.warn('ì˜ì–´ ìë§‰ë„ ì—†ìŒ');
        }
      }
      
      return '';
    }
  }

  // ê°„ë‹¨í•œ ìë§‰ ì¶”ì¶œ (API í‚¤ ì—†ì´ë„ ê°€ëŠ¥)
  async extractSubtitlesSimple(videoId: string): Promise<SubtitleTrack[]> {
    try {
      console.log(`ğŸ“ ê°„ë‹¨ ìë§‰ ì¶”ì¶œ: ${videoId}`);

      const subtitles: SubtitleTrack[] = [];

      // í•œêµ­ì–´ ìë§‰ ì‹œë„
      const koreanText = await this.fetchSubtitleText(videoId, 'ko');
      if (koreanText) {
        subtitles.push({
          language: 'ko',
          text: koreanText,
          isAutoGenerated: true // youtube-transcriptëŠ” ëŒ€ë¶€ë¶„ ìë™ìƒì„±
        });
      }

      // í•œêµ­ì–´ê°€ ì—†ìœ¼ë©´ ì˜ì–´ ì‹œë„
      if (subtitles.length === 0) {
        const englishText = await this.fetchSubtitleText(videoId, 'en');
        if (englishText) {
          subtitles.push({
            language: 'en',
            text: englishText,
            isAutoGenerated: true
          });
        }
      }

      console.log(`âœ… ê°„ë‹¨ ìë§‰ ì¶”ì¶œ ì™„ë£Œ: ${subtitles.length}ê°œ`);
      return subtitles;

    } catch (error) {
      console.error(`âŒ ê°„ë‹¨ ìë§‰ ì¶”ì¶œ ì‹¤íŒ¨: ${videoId}`, error);
      return [];
    }
  }
}

// ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
export const youtubeAPI = new YouTubeAPI();