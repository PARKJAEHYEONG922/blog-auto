interface YouTubeAPIConfig {
  apiKey: string;
}

export interface YouTubeVideoItem {
  id: {
    videoId: string;
  };
  snippet: {
    title: string;
    description: string;
    channelTitle: string;
    channelId: string;
    publishedAt: string;
    thumbnails: {
      default: {
        url: string;
      };
    };
    tags?: string[];
    categoryId?: string;
  };
}

interface YouTubeVideoDetails {
  id: string;
  statistics: {
    viewCount: string;
    likeCount?: string;
    commentCount?: string;
  };
  contentDetails: {
    duration: string;
    definition: string;
    caption: string;
  };
  snippet: {
    channelId: string;
    publishedAt: string;
    title: string;
  };
}

interface YouTubeChannelDetails {
  id: string;
  statistics: {
    subscriberCount: string;
  };
}

export interface PrioritizedVideo {
  videoId: string;
  title: string;
  channelTitle: string;
  publishedAt: string;
  viewCount: number;
  duration: number; // seconds
  subscriberCount?: number;
  priority: number;
  url: string;
}

export interface SubtitleTrack {
  language: string;
  text: string;
  isAutoGenerated: boolean;
}

interface YouTubeSearchResponse {
  items: YouTubeVideoItem[];
  pageInfo: {
    totalResults: number;
    resultsPerPage: number;
  };
}

export class YouTubeAPI {
  private config: YouTubeAPIConfig | null = null;

  async loadConfig(): Promise<void> {
    try {
      // YouTube API 설정을 로컬스토리지나 Electron 설정에서 로드
      if ((window as any).electronAPI && typeof (window as any).electronAPI.loadYouTubeApiSettings === 'function') {
        const result = await (window as any).electronAPI.loadYouTubeApiSettings();
        if (result && result.success && result.data) {
          this.config = {
            apiKey: result.data.apiKey
          };
          console.log('✅ YouTube API 설정 로드 성공');
        } else {
          console.warn('⚠️ YouTube API 설정이 없습니다');
        }
      } else {
        console.warn('⚠️ Electron API가 없습니다 (브라우저 환경)');
      }
    } catch (error) {
      console.error('❌ YouTube API 설정 로드 실패:', error);
      throw new Error(`YouTube API 설정 로드 실패: ${error.message}`);
    }
  }

  async searchVideos(keyword: string, maxResults: number = 10): Promise<YouTubeVideoItem[]> {
    if (!this.config) {
      throw new Error('YouTube API 설정이 로드되지 않았습니다. loadConfig()를 먼저 호출하세요.');
    }

    try {
      const encodedKeyword = encodeURIComponent(keyword);
      const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodedKeyword}&key=${this.config.apiKey}&type=video&maxResults=${maxResults}&order=relevance`;

      console.log(`📺 YouTube API 검색: ${keyword} (최대 ${maxResults}개)`);

      const response = await fetch(url);
      
      if (!response.ok) {
        if (response.status === 403) {
          throw new Error('YouTube API 할당량 초과 또는 API 키가 유효하지 않습니다');
        } else if (response.status === 400) {
          throw new Error('YouTube API 요청 형식이 잘못되었습니다');
        } else {
          throw new Error(`YouTube API 호출 실패: ${response.status} ${response.statusText}`);
        }
      }

      const data: YouTubeSearchResponse = await response.json();
      
      console.log(`✅ YouTube 검색 완료: ${data.items.length}개 동영상`);
      
      return data.items;

    } catch (error) {
      console.error('❌ YouTube 검색 실패:', error);
      throw error;
    }
  }

  async getVideoDetails(videoId: string): Promise<any> {
    if (!this.config) {
      throw new Error('YouTube API 설정이 로드되지 않았습니다');
    }

    try {
      const url = `https://www.googleapis.com/youtube/v3/videos?part=statistics,contentDetails&id=${videoId}&key=${this.config.apiKey}`;
      
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`YouTube API 호출 실패: ${response.status}`);
      }

      const data = await response.json();
      return data.items[0];

    } catch (error) {
      console.error('❌ YouTube 동영상 상세 정보 조회 실패:', error);
      throw error;
    }
  }

  // ISO 8601 duration을 사람이 읽기 쉬운 형태로 변환
  static parseDuration(duration: string): string {
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return '0:00';

    const hours = parseInt(match[1] || '0');
    const minutes = parseInt(match[2] || '0');
    const seconds = parseInt(match[3] || '0');

    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    } else {
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
  }

  // 조회수를 한국어 형태로 변환
  static formatViewCount(viewCount: string): string {
    const count = parseInt(viewCount);
    if (count >= 10000) {
      return `${Math.floor(count / 10000)}만회`;
    } else if (count >= 1000) {
      return `${(count / 1000).toFixed(1)}천회`;
    } else {
      return `${count}회`;
    }
  }

  // 우선순위 기반 동영상 검색 및 선별
  async searchPrioritizedVideos(keyword: string, maxResults: number = 10): Promise<PrioritizedVideo[]> {
    if (!this.config) {
      throw new Error('YouTube API 설정이 로드되지 않았습니다. loadConfig()를 먼저 호출하세요.');
    }

    try {
      console.log(`🎯 우선순위 기반 YouTube 검색: ${keyword}`);

      // 1. 기본 검색 (더 많은 결과를 가져와서 필터링)
      const searchResults = await this.searchVideosWithFilters(keyword, Math.min(maxResults * 3, 50));
      
      if (searchResults.length === 0) {
        console.warn('검색 결과가 없습니다');
        return [];
      }

      // 2. 동영상 상세 정보 가져오기 (배치 처리)
      const videoIds = searchResults.map(video => video.id.videoId);
      const videoDetails = await this.getMultipleVideoDetails(videoIds);
      
      // 3. 채널 정보 가져오기 (배치 처리)
      const channelIds = [...new Set(searchResults.map(video => video.snippet.channelId))];
      const channelDetails = await this.getMultipleChannelDetails(channelIds);

      // 4. 우선순위 계산 및 정렬
      const prioritizedVideos: PrioritizedVideo[] = [];

      for (const video of searchResults) {
        const details = videoDetails.find(d => d.id === video.id.videoId);
        const channel = channelDetails.find(c => c.id === video.snippet.channelId);
        
        if (!details) continue;

        const prioritizedVideo: PrioritizedVideo = {
          videoId: video.id.videoId,
          title: video.snippet.title,
          channelTitle: video.snippet.channelTitle,
          publishedAt: video.snippet.publishedAt,
          viewCount: parseInt(details.statistics.viewCount || '0'),
          duration: this.parseDurationToSeconds(details.contentDetails.duration),
          subscriberCount: channel ? parseInt(channel.statistics.subscriberCount || '0') : 0,
          priority: 0,
          url: `https://www.youtube.com/watch?v=${video.id.videoId}`
        };

        // 우선순위 점수 계산
        prioritizedVideo.priority = this.calculatePriority(prioritizedVideo);
        
        // 기본 필터링 조건
        if (this.passesBasicFilters(prioritizedVideo)) {
          prioritizedVideos.push(prioritizedVideo);
        }
      }

      // 5. 우선순위 순으로 정렬 후 상위 N개 반환
      const sortedVideos = prioritizedVideos
        .sort((a, b) => b.priority - a.priority)
        .slice(0, maxResults);

      console.log(`✅ 우선순위 분석 완료: ${sortedVideos.length}개 동영상 선별`);
      return sortedVideos;

    } catch (error) {
      console.error('❌ 우선순위 기반 검색 실패:', error);
      throw error;
    }
  }

  // 필터가 적용된 검색
  private async searchVideosWithFilters(keyword: string, maxResults: number): Promise<YouTubeVideoItem[]> {
    const encodedKeyword = encodeURIComponent(keyword);
    
    // 최근 1년 이내의 영상만 검색
    const oneYearAgo = new Date();
    oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
    const publishedAfter = oneYearAgo.toISOString();

    const url = `https://www.googleapis.com/youtube/v3/search?` +
      `part=snippet&q=${encodedKeyword}&key=${this.config.apiKey}&type=video&maxResults=${maxResults}` +
      `&order=relevance&publishedAfter=${publishedAfter}&videoDuration=medium&videoCaption=any`;

    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`YouTube API 검색 실패: ${response.status}`);
    }

    const data: YouTubeSearchResponse = await response.json();
    return data.items;
  }

  // 여러 동영상의 상세 정보를 배치로 가져오기
  private async getMultipleVideoDetails(videoIds: string[]): Promise<YouTubeVideoDetails[]> {
    if (videoIds.length === 0) return [];

    const batchSize = 50; // YouTube API 제한
    const results: YouTubeVideoDetails[] = [];

    for (let i = 0; i < videoIds.length; i += batchSize) {
      const batch = videoIds.slice(i, i + batchSize);
      const url = `https://www.googleapis.com/youtube/v3/videos?` +
        `part=statistics,contentDetails,snippet&id=${batch.join(',')}&key=${this.config.apiKey}`;

      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        results.push(...data.items);
      }
    }

    return results;
  }

  // 여러 채널의 상세 정보를 배치로 가져오기
  private async getMultipleChannelDetails(channelIds: string[]): Promise<YouTubeChannelDetails[]> {
    if (channelIds.length === 0) return [];

    const batchSize = 50;
    const results: YouTubeChannelDetails[] = [];

    for (let i = 0; i < channelIds.length; i += batchSize) {
      const batch = channelIds.slice(i, i + batchSize);
      const url = `https://www.googleapis.com/youtube/v3/channels?` +
        `part=statistics&id=${batch.join(',')}&key=${this.config.apiKey}`;

      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        results.push(...data.items);
      }
    }

    return results;
  }

  // 우선순위 점수 계산
  private calculatePriority(video: PrioritizedVideo): number {
    let score = 0;

    // 1. 조회수 점수 (40%)
    if (video.viewCount > 1000000) score += 40;
    else if (video.viewCount > 100000) score += 30;
    else if (video.viewCount > 10000) score += 20;
    else if (video.viewCount > 1000) score += 10;

    // 2. 업로드 날짜 점수 (25%)
    const daysSince = (Date.now() - new Date(video.publishedAt).getTime()) / (1000 * 60 * 60 * 24);
    if (daysSince < 30) score += 25;      // 1개월 이내
    else if (daysSince < 90) score += 20; // 3개월 이내
    else if (daysSince < 180) score += 15; // 6개월 이내
    else if (daysSince < 365) score += 10; // 1년 이내

    // 3. 영상 길이 점수 (20%)
    if (video.duration >= 300 && video.duration <= 1200) score += 20; // 5-20분
    else if (video.duration >= 180 && video.duration <= 1800) score += 15; // 3-30분
    else if (video.duration >= 120) score += 10; // 2분 이상

    // 4. 채널 신뢰성 점수 (15%)
    if (video.subscriberCount && video.subscriberCount > 100000) score += 15;
    else if (video.subscriberCount && video.subscriberCount > 10000) score += 10;
    else if (video.subscriberCount && video.subscriberCount > 1000) score += 5;

    return score;
  }

  // 기본 필터링 조건
  private passesBasicFilters(video: PrioritizedVideo): boolean {
    // 최소 조건들
    if (video.viewCount < 100) return false; // 최소 조회수
    if (video.duration < 60) return false;   // 최소 1분
    if (video.duration > 3600) return false; // 최대 1시간
    
    // 1년 이내 영상만
    const oneYearAgo = Date.now() - (365 * 24 * 60 * 60 * 1000);
    if (new Date(video.publishedAt).getTime() < oneYearAgo) return false;

    return true;
  }

  // ISO 8601 duration을 초로 변환
  private parseDurationToSeconds(duration: string): number {
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return 0;

    const hours = parseInt(match[1] || '0');
    const minutes = parseInt(match[2] || '0');
    const seconds = parseInt(match[3] || '0');

    return hours * 3600 + minutes * 60 + seconds;
  }

  // 자막 추출 (외부 라이브러리 없이 구현)
  async extractSubtitles(videoId: string): Promise<SubtitleTrack[]> {
    try {
      console.log(`📝 자막 추출 시작: ${videoId}`);

      // YouTube 자막은 직접 API로 가져올 수 없어서 
      // 대체 방법을 사용 (youtube-transcript 같은 npm 패키지가 필요)
      
      // 일단 API로 자막 트랙 목록은 가져올 수 있음
      const captionTracks = await this.getCaptionTracks(videoId);
      
      if (captionTracks.length === 0) {
        console.warn(`자막이 없는 동영상: ${videoId}`);
        return [];
      }

      // 실제 자막 텍스트는 별도 서비스나 라이브러리 필요
      // 여기서는 구조만 준비
      const subtitles: SubtitleTrack[] = [];
      
      for (const track of captionTracks) {
        try {
          const subtitleText = await this.fetchSubtitleText(track.id);
          subtitles.push({
            language: track.language,
            text: subtitleText,
            isAutoGenerated: track.kind === 'asr'
          });
        } catch (error) {
          console.warn(`자막 추출 실패 (${track.language}):`, error);
        }
      }

      console.log(`✅ 자막 추출 완료: ${subtitles.length}개 언어`);
      return subtitles;

    } catch (error) {
      console.error(`❌ 자막 추출 실패: ${videoId}`, error);
      return [];
    }
  }

  // 자막 트랙 목록 가져오기
  private async getCaptionTracks(videoId: string): Promise<any[]> {
    const url = `https://www.googleapis.com/youtube/v3/captions?part=snippet&videoId=${videoId}&key=${this.config.apiKey}`;
    
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`자막 트랙 조회 실패: ${response.status}`);
    }

    const data = await response.json();
    return data.items || [];
  }

  // 실제 자막 텍스트 가져오기 (youtube-transcript 사용)
  private async fetchSubtitleText(videoId: string, language?: string): Promise<string> {
    try {
      // Node.js 환경에서만 동작
      if (typeof window !== 'undefined') {
        console.warn('자막 추출은 Node.js 환경에서만 가능합니다');
        return '';
      }

      // youtube-transcript 동적 import
      const { YoutubeTranscript } = await import('youtube-transcript');
      
      const transcript = await YoutubeTranscript.fetchTranscript(videoId, {
        lang: language || 'ko'
      });

      // 자막 텍스트 조합
      const fullText = transcript
        .map(item => item.text)
        .join(' ')
        .replace(/\s+/g, ' ')
        .trim();

      return fullText;

    } catch (error) {
      console.warn(`자막 추출 실패 (${videoId}):`, error.message);
      
      // 한국어 자막이 없으면 영어 시도
      if (language !== 'en') {
        try {
          return await this.fetchSubtitleText(videoId, 'en');
        } catch (enError) {
          console.warn('영어 자막도 없음');
        }
      }
      
      return '';
    }
  }

  // 간단한 자막 추출 (API 키 없이도 가능)
  async extractSubtitlesSimple(videoId: string): Promise<SubtitleTrack[]> {
    try {
      console.log(`📝 간단 자막 추출: ${videoId}`);

      const subtitles: SubtitleTrack[] = [];

      // 한국어 자막 시도
      const koreanText = await this.fetchSubtitleText(videoId, 'ko');
      if (koreanText) {
        subtitles.push({
          language: 'ko',
          text: koreanText,
          isAutoGenerated: true // youtube-transcript는 대부분 자동생성
        });
      }

      // 한국어가 없으면 영어 시도
      if (subtitles.length === 0) {
        const englishText = await this.fetchSubtitleText(videoId, 'en');
        if (englishText) {
          subtitles.push({
            language: 'en',
            text: englishText,
            isAutoGenerated: true
          });
        }
      }

      console.log(`✅ 간단 자막 추출 완료: ${subtitles.length}개`);
      return subtitles;

    } catch (error) {
      console.error(`❌ 간단 자막 추출 실패: ${videoId}`, error);
      return [];
    }
  }
}

// 싱글톤 인스턴스
export const youtubeAPI = new YouTubeAPI();