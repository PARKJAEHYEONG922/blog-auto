interface YouTubeAPIConfig {
  apiKey: string;
}

export interface YouTubeVideoItem {
  id: {
    videoId: string;
  };
  snippet: {
    title: string;
    description: string;
    channelTitle: string;
    channelId: string;
    publishedAt: string;
    thumbnails: {
      default: {
        url: string;
      };
    };
    tags?: string[];
    categoryId?: string;
  };
}

interface YouTubeVideoDetails {
  id: string;
  statistics: {
    viewCount: string;
    likeCount?: string;
    commentCount?: string;
  };
  contentDetails: {
    duration: string;
    definition: string;
    caption: string;
  };
  snippet: {
    channelId: string;
    publishedAt: string;
    title: string;
  };
}

interface YouTubeChannelDetails {
  id: string;
  statistics: {
    subscriberCount: string;
  };
}

export interface PrioritizedVideo {
  videoId: string;
  title: string;
  channelTitle: string;
  publishedAt: string;
  viewCount: number;
  duration: number; // seconds
  subscriberCount?: number;
  priority: number;
}

export interface SubtitleTrack {
  language: string;
  text: string;
  isAutoGenerated: boolean;
}

interface YouTubeSearchResponse {
  items: YouTubeVideoItem[];
  pageInfo: {
    totalResults: number;
    resultsPerPage: number;
  };
}

export class YouTubeAPI {
  private config: YouTubeAPIConfig | null = null;

  async loadConfig(): Promise<void> {
    try {
      // YouTube API ì„¤ì •ì„ ë¡œì»¬ìŠ¤í† ë¦¬ì§€ë‚˜ Electron ì„¤ì •ì—ì„œ ë¡œë“œ
      if ((window as any).electronAPI && typeof (window as any).electronAPI.loadYouTubeApiSettings === 'function') {
        const result = await (window as any).electronAPI.loadYouTubeApiSettings();
        if (result && result.success && result.data) {
          this.config = {
            apiKey: result.data.apiKey
          };
          console.log('âœ… YouTube API ì„¤ì • ë¡œë“œ ì„±ê³µ');
        } else {
          console.warn('âš ï¸ YouTube API ì„¤ì •ì´ ì—†ìŠµë‹ˆë‹¤');
        }
      } else {
        console.warn('âš ï¸ Electron APIê°€ ì—†ìŠµë‹ˆë‹¤ (ë¸Œë¼ìš°ì € í™˜ê²½)');
      }
    } catch (error) {
      console.error('âŒ YouTube API ì„¤ì • ë¡œë“œ ì‹¤íŒ¨:', error);
      throw new Error(`YouTube API ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: ${error.message}`);
    }
  }

  async searchVideos(keyword: string, maxResults = 10): Promise<YouTubeVideoItem[]> {
    if (!this.config) {
      throw new Error('YouTube API ì„¤ì •ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. loadConfig()ë¥¼ ë¨¼ì € í˜¸ì¶œí•˜ì„¸ìš”.');
    }

    try {
      const encodedKeyword = encodeURIComponent(keyword);
      const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodedKeyword}&key=${this.config.apiKey}&type=video&maxResults=${maxResults}&order=relevance`;

      console.log(`ğŸ“º YouTube API ê²€ìƒ‰: ${keyword} (ìµœëŒ€ ${maxResults}ê°œ)`);

      const response = await fetch(url);
      
      if (!response.ok) {
        if (response.status === 403) {
          throw new Error('YouTube API í• ë‹¹ëŸ‰ ì´ˆê³¼ ë˜ëŠ” API í‚¤ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
        } else if (response.status === 400) {
          throw new Error('YouTube API ìš”ì²­ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤');
        } else {
          throw new Error(`YouTube API í˜¸ì¶œ ì‹¤íŒ¨: ${response.status} ${response.statusText}`);
        }
      }

      const data: YouTubeSearchResponse = await response.json();
      
      console.log(`âœ… YouTube ê²€ìƒ‰ ì™„ë£Œ: ${data.items.length}ê°œ ë™ì˜ìƒ`);
      
      return data.items;

    } catch (error) {
      console.error('âŒ YouTube ê²€ìƒ‰ ì‹¤íŒ¨:', error);
      throw error;
    }
  }

  async getVideoDetails(videoId: string): Promise<any> {
    if (!this.config) {
      throw new Error('YouTube API ì„¤ì •ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');
    }

    try {
      const url = `https://www.googleapis.com/youtube/v3/videos?part=statistics,contentDetails&id=${videoId}&key=${this.config.apiKey}`;
      
      const response = await fetch(url);
      
      if (!response.ok) {
        throw new Error(`YouTube API í˜¸ì¶œ ì‹¤íŒ¨: ${response.status}`);
      }

      const data = await response.json();
      return data.items[0];

    } catch (error) {
      console.error('âŒ YouTube ë™ì˜ìƒ ìƒì„¸ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:', error);
      throw error;
    }
  }

  // ISO 8601 durationì„ ì‚¬ëŒì´ ì½ê¸° ì‰¬ìš´ í˜•íƒœë¡œ ë³€í™˜
  static parseDuration(duration: string): string {
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return '0:00';

    const hours = parseInt(match[1] || '0');
    const minutes = parseInt(match[2] || '0');
    const seconds = parseInt(match[3] || '0');

    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    } else {
      return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
  }

  // ì¡°íšŒìˆ˜ë¥¼ í•œêµ­ì–´ í˜•íƒœë¡œ ë³€í™˜
  static formatViewCount(viewCount: string): string {
    const count = parseInt(viewCount);
    if (count >= 10000) {
      return `${Math.floor(count / 10000)}ë§ŒíšŒ`;
    } else if (count >= 1000) {
      return `${(count / 1000).toFixed(1)}ì²œíšŒ`;
    } else {
      return `${count}íšŒ`;
    }
  }

  // ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ë™ì˜ìƒ ê²€ìƒ‰ ë° ì„ ë³„
  async searchPrioritizedVideos(keyword: string, maxResults = 10): Promise<PrioritizedVideo[]> {
    if (!this.config) {
      throw new Error('YouTube API ì„¤ì •ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. loadConfig()ë¥¼ ë¨¼ì € í˜¸ì¶œí•˜ì„¸ìš”.');
    }

    try {
      console.log(`ğŸ¯ ìš°ì„ ìˆœìœ„ ê¸°ë°˜ YouTube ê²€ìƒ‰: ${keyword}`);

      // 1. ê¸°ë³¸ ê²€ìƒ‰ (ë” ë§ì€ ê²°ê³¼ë¥¼ ê°€ì ¸ì™€ì„œ í•„í„°ë§)
      const searchResults = await this.searchVideosWithFilters(keyword, maxResults);
      
      if (searchResults.length === 0) {
        console.warn('ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤');
        return [];
      }

      // 2. ë™ì˜ìƒ ìƒì„¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ë°°ì¹˜ ì²˜ë¦¬)
      const videoIds = searchResults.map(video => video.id.videoId);
      const videoDetails = await this.getMultipleVideoDetails(videoIds);
      
      // 3. ì±„ë„ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ë°°ì¹˜ ì²˜ë¦¬)
      const channelIds = [...new Set(searchResults.map(video => video.snippet.channelId))];
      const channelDetails = await this.getMultipleChannelDetails(channelIds);

      // 4. ìš°ì„ ìˆœìœ„ ê³„ì‚° ë° ì •ë ¬
      const prioritizedVideos: PrioritizedVideo[] = [];

      for (const video of searchResults) {
        const details = videoDetails.find(d => d.id === video.id.videoId);
        const channel = channelDetails.find(c => c.id === video.snippet.channelId);
        
        if (!details) continue;

        const prioritizedVideo: PrioritizedVideo = {
          videoId: video.id.videoId,
          title: video.snippet.title,
          channelTitle: video.snippet.channelTitle,
          publishedAt: video.snippet.publishedAt,
          viewCount: parseInt(details.statistics.viewCount || '0'),
          duration: this.parseDurationToSeconds(details.contentDetails.duration),
          subscriberCount: channel ? parseInt(channel.statistics.subscriberCount || '0') : 0,
          priority: 0,
          // ì¶”ê°€ ë°ì´í„°
          likeCount: details.statistics.likeCount || 'N/A',
          commentCount: details.statistics.commentCount || 'N/A'
        } as PrioritizedVideo & { likeCount: string; commentCount: string };

        // ìš°ì„ ìˆœìœ„ ì ìˆ˜ ê³„ì‚°
        prioritizedVideo.priority = this.calculatePriority(prioritizedVideo);
        
        // ê¸°ë³¸ í•„í„°ë§ ì¡°ê±´
        if (this.passesBasicFilters(prioritizedVideo)) {
          prioritizedVideos.push(prioritizedVideo);
        }
      }

      // 5. ìš°ì„ ìˆœìœ„ ìˆœìœ¼ë¡œ ì •ë ¬ í›„ ìƒìœ„ Nê°œ ë°˜í™˜
      const sortedVideos = prioritizedVideos
        .sort((a, b) => b.priority - a.priority)
        .slice(0, maxResults);

      console.log(`âœ… ìš°ì„ ìˆœìœ„ ë¶„ì„ ì™„ë£Œ: ${sortedVideos.length}ê°œ ë™ì˜ìƒ ì„ ë³„`);
      return sortedVideos;

    } catch (error) {
      console.error('âŒ ìš°ì„ ìˆœìœ„ ê¸°ë°˜ ê²€ìƒ‰ ì‹¤íŒ¨:', error);
      throw error;
    }
  }

  // í•„í„°ê°€ ì ìš©ëœ ê²€ìƒ‰
  private async searchVideosWithFilters(keyword: string, maxResults: number): Promise<YouTubeVideoItem[]> {
    const encodedKeyword = encodeURIComponent(keyword);

    const url = `https://www.googleapis.com/youtube/v3/search?` +
      `part=snippet&q=${encodedKeyword}&key=${this.config.apiKey}&type=video&maxResults=${maxResults}` +
      `&order=relevance&videoDuration=medium&videoCaption=any`;

    const response = await fetch(url);
    
    if (!response.ok) {
      throw new Error(`YouTube API ê²€ìƒ‰ ì‹¤íŒ¨: ${response.status}`);
    }

    const data: YouTubeSearchResponse = await response.json();
    return data.items;
  }

  // ì—¬ëŸ¬ ë™ì˜ìƒì˜ ìƒì„¸ ì •ë³´ë¥¼ ë°°ì¹˜ë¡œ ê°€ì ¸ì˜¤ê¸°
  private async getMultipleVideoDetails(videoIds: string[]): Promise<YouTubeVideoDetails[]> {
    if (videoIds.length === 0) return [];

    const batchSize = 50; // YouTube API ì œí•œ
    const results: YouTubeVideoDetails[] = [];

    for (let i = 0; i < videoIds.length; i += batchSize) {
      const batch = videoIds.slice(i, i + batchSize);
      const url = `https://www.googleapis.com/youtube/v3/videos?` +
        `part=statistics,contentDetails,snippet&id=${batch.join(',')}&key=${this.config.apiKey}`;

      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        results.push(...data.items);
      }
    }

    return results;
  }

  // ì—¬ëŸ¬ ì±„ë„ì˜ ìƒì„¸ ì •ë³´ë¥¼ ë°°ì¹˜ë¡œ ê°€ì ¸ì˜¤ê¸°
  private async getMultipleChannelDetails(channelIds: string[]): Promise<YouTubeChannelDetails[]> {
    if (channelIds.length === 0) return [];

    const batchSize = 50;
    const results: YouTubeChannelDetails[] = [];

    for (let i = 0; i < channelIds.length; i += batchSize) {
      const batch = channelIds.slice(i, i + batchSize);
      const url = `https://www.googleapis.com/youtube/v3/channels?` +
        `part=statistics&id=${batch.join(',')}&key=${this.config.apiKey}`;

      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        results.push(...data.items);
      }
    }

    return results;
  }

  // ìš°ì„ ìˆœìœ„ ì ìˆ˜ ê³„ì‚° (ë¸”ë¡œê·¸ ì‘ì„± ì°¸ê³ ìš© ì½˜í…ì¸  ì„ ë³„)
  private calculatePriority(video: PrioritizedVideo): number {
    let score = 0;

    // 1. ì¡°íšŒìˆ˜ ì ìˆ˜ (35%) - ë§ì€ ì‚¬ëŒì´ ë³¸ = ìœ ìš©í•œ ì •ë³´ì¼ ê°€ëŠ¥ì„±
    if (video.viewCount > 1000000) score += 35;
    else if (video.viewCount > 500000) score += 30;
    else if (video.viewCount > 100000) score += 25;
    else if (video.viewCount > 50000) score += 20;
    else if (video.viewCount > 10000) score += 15;
    else if (video.viewCount > 1000) score += 10;

    // 2. ì˜ìƒ ê¸¸ì´ ì ìˆ˜ (30%) - ì ì ˆí•œ ê¸¸ì´ = ì¶©ë¶„í•œ ì •ë³´ëŸ‰
    if (video.duration >= 600 && video.duration <= 1200) score += 30; // 10-20ë¶„ (ìµœì )
    else if (video.duration >= 300 && video.duration <= 1800) score += 25; // 5-30ë¶„
    else if (video.duration >= 180 && video.duration <= 1800) score += 20; // 3-30ë¶„
    else if (video.duration >= 120 && video.duration <= 1800) score += 15; // 2-30ë¶„

    // 3. ì±„ë„ ì‹ ë¢°ì„± ì ìˆ˜ (25%) - ì „ë¬¸ì„±ê³¼ ì‹ ë¢°ë„
    if (video.subscriberCount && video.subscriberCount > 1000000) score += 25;
    else if (video.subscriberCount && video.subscriberCount > 500000) score += 22;
    else if (video.subscriberCount && video.subscriberCount > 100000) score += 18;
    else if (video.subscriberCount && video.subscriberCount > 50000) score += 15;
    else if (video.subscriberCount && video.subscriberCount > 10000) score += 12;
    else if (video.subscriberCount && video.subscriberCount > 1000) score += 8;

    // 4. ì—…ë¡œë“œ ë‚ ì§œ ì ìˆ˜ (10%) - ë„ˆë¬´ ì˜¤ë˜ë˜ì§€ ì•Šì€ ì •ë³´ ì„ í˜¸í•˜ë˜ í° ë¹„ì¤‘ X
    const daysSince = (Date.now() - new Date(video.publishedAt).getTime()) / (1000 * 60 * 60 * 24);
    if (daysSince < 365) score += 10;        // 1ë…„ ì´ë‚´
    else if (daysSince < 365 * 2) score += 8; // 2ë…„ ì´ë‚´
    else if (daysSince < 365 * 3) score += 6; // 3ë…„ ì´ë‚´
    else if (daysSince < 365 * 5) score += 4; // 5ë…„ ì´ë‚´
    else score += 2; // 5ë…„ ì´ìƒë„ ì¢‹ì€ ì •ë³´ì¼ ìˆ˜ ìˆìŒ

    return score;
  }

  // ê¸°ë³¸ í•„í„°ë§ ì¡°ê±´
  private passesBasicFilters(video: PrioritizedVideo): boolean {
    // ìµœì†Œ ì¡°ê±´ë“¤
    if (video.viewCount < 100) return false; // ìµœì†Œ ì¡°íšŒìˆ˜
    if (video.duration < 60) return false;   // ìµœì†Œ 1ë¶„
    if (video.duration > 1800) return false; // ìµœëŒ€ 30ë¶„
    

    return true;
  }

  // ISO 8601 durationì„ ì´ˆë¡œ ë³€í™˜
  private parseDurationToSeconds(duration: string): number {
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return 0;

    const hours = parseInt(match[1] || '0');
    const minutes = parseInt(match[2] || '0');
    const seconds = parseInt(match[3] || '0');

    return hours * 3600 + minutes * 60 + seconds;
  }


  // IPCë¥¼ í†µí•œ ìë§‰ ì¶”ì¶œ (ë©”ì¸ í”„ë¡œì„¸ìŠ¤ì—ì„œ ì‹¤í–‰)
  private async fetchSubtitleText(videoId: string, language?: string): Promise<string> {
    try {
      console.log(`ğŸ” [ë Œë”ëŸ¬] ìë§‰ ì¶”ì¶œ ìš”ì²­: ${videoId} (ì–¸ì–´: ${language || 'ko'})`);
      
      // ë©”ì¸ í”„ë¡œì„¸ìŠ¤ë¡œ ìë§‰ ì¶”ì¶œ ìš”ì²­
      const result = await (window as any).electronAPI.extractYouTubeSubtitles(videoId, language || 'ko');
      
      if (result.success && result.data) {
        console.log(`âœ… [ë Œë”ëŸ¬] ìë§‰ ì¶”ì¶œ ì„±ê³µ: ${result.data.length}ì`);
        return result.data.text;
      } else {
        console.error(`âŒ [ë Œë”ëŸ¬] ìë§‰ ì¶”ì¶œ ì‹¤íŒ¨: ${result.message}`);
        return '';
      }

    } catch (error) {
      console.error(`âŒ [ë Œë”ëŸ¬] ìë§‰ ì¶”ì¶œ ì‹œìŠ¤í…œ ì˜¤ë¥˜ (${videoId}):`, error);
      return '';
    }
  }



  // ê°„ë‹¨í•œ ìë§‰ ì¶”ì¶œ (300ì ì´ìƒë§Œ í†µê³¼)
  async extractSubtitlesSimple(videoId: string): Promise<SubtitleTrack[]> {
    try {
      console.log(`ğŸ¬ extractSubtitlesSimple ì‹œì‘: ${videoId}`);
      
      // IPC í†µì‹ ìœ¼ë¡œ ë©”ì¸ í”„ë¡œì„¸ìŠ¤ì—ì„œ ìë§‰ ì¶”ì¶œ
      console.log(`ğŸ”„ IPC í†µì‹ ìœ¼ë¡œ ìë§‰ ì¶”ì¶œ ì‹œë„: ${videoId}`);
      const result = await (window as any).electronAPI.extractYouTubeSubtitles(videoId, 'ko');
      
      if (result.success && result.data && result.data.text) {
        console.log(`âœ… IPC ìë§‰ ì¶”ì¶œ ì„±ê³µ: ${result.data.language} ${result.data.length}ì`);
        return [{
          language: result.data.language,
          text: result.data.text,
          isAutoGenerated: result.data.isAutoGenerated || true
        }];
      } else {
        console.warn(`âš ï¸ IPC ìë§‰ ì¶”ì¶œ ì‹¤íŒ¨: ${result.message}`);
        return [];
      }

    } catch (error) {
      console.error(`ğŸ’¥ extractSubtitlesSimple ì „ì²´ ì‹¤íŒ¨: ${videoId}`, error);
      return [];
    }
  }
}

// ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
export const youtubeAPI = new YouTubeAPI();